pos = 4,
font = 2,
col = "#404040"
)
text(
10.5 * k,
y = 58.7 * k,
"(in € per inh. in 2016)",
cex = 0.55,
pos = 4,
font = 1,
col = "#404040"
)
dev.off()
nuts.borders  <- st_intersection(st_buffer(nuts, 5), st_buffer(nuts, 5))
nuts.borders  <- st_cast(nuts.borders ,"MULTILINESTRING")
nuts.borders  <- nuts.borders [nuts.borders $id != nuts.borders $id.1, ]
nuts.borders$id1 = nuts.borders$id
nuts.borders$id2 = nuts.borders$id.1
nuts.borders$id =  paste0(nuts.borders$id1, "_", nuts.borders$id2)
rownames(nuts.borders) = nuts.borders$id
nuts.borders  = nuts.borders [,c("id","id1","id2","geometry")]
vals <- nuts[,c("id","GDPINH_2016")] %>% st_set_geometry(NULL)
nuts.borders <- merge (x = nuts.borders, y = vals,
by.x = "id1", by.y = "id", all.x = T)
nuts.borders <- merge (x = nuts.borders, y = vals,
by.x = "id2", by.y = "id", all.x = T)
nuts.borders$disc <- nuts.borders$GDPINH_2016.x / nuts.borders$GDPINH_2016.y
threshold <- 0.95
disc <- nuts.borders[nuts.borders$disc >= quantile(nuts.borders$disc,threshold),]
template("figures/fig3.png")
mf_map(
x = disc,
col = "#d92e94",
lwd = 3,
add = TRUE
)
dev.off()
# On séléctionne une ligne au hasard
line <- st_geometry(disc[5, ])
# nombre d'itérations
nb <- 15
# valeur de translation
delta <- 200
# On effectue une boucle
par(mar = c(0, 0, 0, 0), bg = "#f2efe6")
mf_map(line, col = "#66666690", lwd = 0.5)
for (j in 1:nb) {
line <- line + c(0, delta)
mf_map(line,
col = "#66666690",
lwd = 0.5 ,
add = TRUE)
}
# On affiche la derinière ligne en rouge avec une épaisseur de 1.2
mf_map(line,
col = "#cf0e00",
lwd = 1.2,
add = TRUE)
disc <- st_cast(disc,"LINESTRING")
c <- as.data.frame(st_coordinates(st_centroid(disc)))
disc$Y <- c$Y
disc <- disc[order(disc$Y, decreasing = TRUE), ]
disc$c1 <- substr(disc$id1,1,2)
disc$c2 <- substr(disc$id2,1,2)
# Discontinuities between two regions of two different countries
disc$height <- round(scales::rescale(disc$disc, to=c(30,70)),0)
disc$col <-"#cf0e00"
disc$thickness <- 1.2
# Discontinuities between two regions of the same country
for (i in 1:length(disc$disc)){ if (disc$c1[i]== disc$c2[i]) {
disc$height[i] <- 8
disc$col[i] <-"#66666690"
disc$thickness[i] <- 0.5
}
}
delta <- 2500 # spacing between lines (walls)
extrude <- function(id){
line <- st_geometry(disc[id,])
mf_map(line, col= "#66666690",lwd = 0.5 ,add= TRUE)
nb <- as.numeric(disc[id,"height"])[1]
for (j in 1:nb){
line <- st_geometry(line) + c(0,delta)
mf_map(st_geometry(line), col= "#66666690",lwd = 0.5 ,add= TRUE)
}
mf_map(line, col= disc$col[id],lwd = disc$thickness[id] ,add= TRUE)
}
template("figures/fig4.png")
for (i in 1:length(disc$height))
{
extrude(i)
}
# Habillage
d = 0.75 * k
text(14.4*k - d, y = 57.4*k, "Discontinuities", cex = 0.6,
pos = 4, font = 2, col="#404040")
text(15.5*k - d, y = 56.6*k, "Between two regions of the same country",
cex = 0.4, pos = 4, font = 1, col="#404040")
text(15.5*k - d, y = 55.7*k, "Between two regions of two different countries",
cex = 0.4, pos = 4, font = 1, col="#404040")
text(15.5*k - d, y = 55.3*k,
"(The height is proportional to the value of the dicontinuity)",
cex = 0.4, pos = 4, font = 1, col="#404040")
text(10.7*k, y = 54.4*k,
"NB: only the 10% highest discontinuities are represented on the map.",
cex = 0.4, pos = 4, font = 3, col="#404040")
# Lignes
myline <- disc[disc$id == "TR21_BG341",]
st_geometry(myline) <- st_geometry(myline) + c(4.2*k, 5*k)
myline2 <- myline
st_geometry(myline2) <- st_geometry(myline2) + c(0, 1.5*k)
# discontinuités entre deux régions de deux pays différentes
plot(myline, col= "#66666690",lwd = 0.5 ,add= T)
for (i in 1:40){
myline <- st_geometry(myline) + c(0,delta)
plot(st_geometry(myline), col= "#66666690",lwd = 0.5 ,add= T)
}
plot(myline, col= "#cf0e00",lwd = 1.2 ,add= T)
# discontinuités entre deux régions d'un même pays
plot(myline2, col= "#66666690",lwd = 0.5 ,add= T)
for (i in 1:8){
myline2 <- st_geometry(myline2) + c(0,delta)
plot(st_geometry(myline2), col= "#66666690",lwd = 0.5 ,add= T)
}
plot(myline2, col= "#66666690",lwd = 0.5 ,add= T)
dev.off()
template("figures/ironcurtain.png")
mf_map(
x = nuts,
var = "GDPINH_2016",
type = "choro",
breaks = bks,
pal = cols,
lwd = 0.2,
leg_pos = "n",
add = TRUE
)
mf_legend(
type = "choro",
pos = c(11 * k, 59.05 * k),
title = "",
val = bks,
val_cex = 0.4,
pal = cols,
fg = "#333333",
cex = 0.85,
border = "red",
val_rnd = 0,
no_data = FALSE,
frame = FALSE
)
text(
10.5 * k,
y = 59.1 * k,
"Gross Domestic Product",
cex = 0.75,
pos = 4,
font = 2,
col = "#404040"
)
text(
10.5 * k,
y = 58.7 * k,
"(in € per inh. in 2016)",
cex = 0.55,
pos = 4,
font = 1,
col = "#404040"
)
for (i in 1:length(disc$height))
{
extrude(i)
}
# Habillage
d = 0.75 * k
text(14.4*k - d, y = 57.4*k, "Discontinuities", cex = 0.6,
pos = 4, font = 2, col="#404040")
text(15.5*k - d, y = 56.6*k, "Between two regions of the same country",
cex = 0.4, pos = 4, font = 1, col="#404040")
text(15.5*k - d, y = 55.7*k, "Between two regions of two different countries",
cex = 0.4, pos = 4, font = 1, col="#404040")
text(15.5*k - d, y = 55.3*k,
"(The height is proportional to the value of the dicontinuity)",
cex = 0.4, pos = 4, font = 1, col="#404040")
text(10.7*k, y = 54.4*k,
"NB: only the 10% highest discontinuities are represented on the map.",
cex = 0.4, pos = 4, font = 3, col="#404040")
# Lignes
myline <- disc[disc$id == "TR21_BG341",]
st_geometry(myline) <- st_geometry(myline) + c(4.2*k, 5*k)
myline2 <- myline
st_geometry(myline2) <- st_geometry(myline2) + c(0, 1.5*k)
# discontinuités entre deux régions de deux pays différentes
plot(myline, col= "#66666690",lwd = 0.5 ,add= T)
for (i in 1:40){
myline <- st_geometry(myline) + c(0,delta)
plot(st_geometry(myline), col= "#66666690",lwd = 0.5 ,add= T)
}
plot(myline, col= "#cf0e00",lwd = 1.2 ,add= T)
# discontinuités entre deux régions d'un même pays
plot(myline2, col= "#66666690",lwd = 0.5 ,add= T)
for (i in 1:8){
myline2 <- st_geometry(myline2) + c(0,delta)
plot(st_geometry(myline2), col= "#66666690",lwd = 0.5 ,add= T)
}
plot(myline2, col= "#66666690",lwd = 0.5 ,add= T)
dev.off()
## Global options
knitr::opts_chunk$set(echo=TRUE,
cache=FALSE,
prompt=FALSE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="bg-info",
class.output="bg-warning")
library("sf")
library("mapsf")
library("eurostat")
library("rnaturalearth")
# NUTS 2016
nuts2016 <- get_eurostat_geospatial(
output_class = "sf",
resolution = "20",
nuts_level = "all",
year = "2016"
)
# Couche géographique des NUTS3 et NUTS2 pour 2016
nuts2016_3 <- nuts2016[nuts2016$LEVL_CODE == 3, ]
nuts2016_2 <- nuts2016[nuts2016$LEVL_CODE == 2, ]
# Liste des pays (code ISO) pour lesquels on s’intéresse aux NUTS2
N2 <- c("AT", "BE", "CH", "DE", "EL", "NL", "UK", "TR", "IE", "IS", "NO")
# Couche géographique NUTS2/3 en fonction de la liste de pays N2
nuts <- rbind(nuts2016_2[nuts2016_2$CNTR_CODE %in% N2, ],
nuts2016_3[!nuts2016_3$CNTR_CODE %in% N2, ])
# Suppression des départements d'Outre-mer français
nuts <- nuts[!nuts$id %in% c("FRY10", "FRY20", "FRY30", "FRY40", "FRY50"), ]
# Suppression du découpage NUTS 2016 pour le Royaume-Uni
nuts <- nuts[nuts$CNTR_CODE != "UK", ]
# Sélection et renommage de colonnes
nuts <- nuts[,c("id","NUTS_NAME","geometry")]
colnames(nuts) <- c("id","name","geometry")
# Récupération du découpage NUTS2 2013
nuts2013 <- get_eurostat_geospatial(
output_class = "sf",
resolution = "20",
nuts_level = "2",
year = "2013"
)
# Sélection des NUTS2 du Royaume-Uni et renommage de colonnes
uk <- nuts2013[nuts2013$CNTR_CODE == "UK",]
# Sélection et renommage de colonnes
uk <- uk[,c("id","NUTS_NAME","geometry")]
colnames(uk) <- c("id","name","geometry")
# Fusion des NUTS2 2013 du Royaume-Uni avec le fond de carte NUTS2/3 2016
nuts <- rbind(nuts, uk)
par(mar = c(0, 0, 0, 0), mfrow = c(1, 3))
mf_map(nuts, col = "#CCCCCC", border = NA)
mf_map(nuts[substr(nuts$id,1,2) %in%  c("AT", "BE", "CH", "DE", "EL", "NL", "TR", "IE", "IS", "NO"),],
col = "#6eb1db",
border = "white",
lwd = 0.2, add = TRUE)
mf_title("NUTS 2 (version 2016)", bg = "#6eb1db")
mf_map(nuts, col = "#CCCCCC", border = NA)
mf_map(nuts[!substr(nuts$id,1,2) %in%  c("AT", "BE", "CH", "DE", "EL", "NL", "UK", "TR", "IE", "IS", "NO", "UK"),],
col = "#6eb1db",
border = "white",
lwd = 0.2, add = TRUE)
mf_title("NUTS 3 (version 2016)", bg = "#6eb1db")
mf_map(nuts, col = "#CCCCCC", border = NA)
mf_map(nuts[substr(nuts$id,1,2) == "UK",],
col = "#6eb1db",
border = "white",
lwd = 0.2, add = TRUE)
mf_title("NUTS 2 (version 2013)", bg = "#6eb1db")
# Récupération des données (PIB/hab)
var <- "nama_10r_3gdp"
gdpinh <- get_eurostat(var, time_format = "num")
# Sélection de l'unité de mesure et de la date
gdpinh <- gdpinh[gdpinh$unit == "EUR_HAB",]
gdpinh <- gdpinh[gdpinh$time == 2016,c("geo","values")]
colnames(gdpinh) <- c("id","GDPINH_2016")
?sf_use_s2
?st_as_sfc
## Global options
knitr::opts_chunk$set(echo=TRUE,
cache=FALSE,
prompt=FALSE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="bg-info",
class.output="bg-warning")
library("sf")
library("mapsf")
library("eurostat")
library("rnaturalearth")
# NUTS 2016
nuts2016 <- get_eurostat_geospatial(
output_class = "sf",
resolution = "20",
nuts_level = "all",
year = "2016")
# Couche géographique des NUTS3 et NUTS2 pour 2016
nuts2016_3 <- nuts2016[nuts2016$LEVL_CODE == 3, ]
nuts2016_2 <- nuts2016[nuts2016$LEVL_CODE == 2, ]
# Liste des pays (code ISO) pour lesquels on s’intéresse aux NUTS2
N2 <- c("AT", "BE", "CH", "DE", "EL", "NL", "UK", "TR", "IE", "IS", "NO")
# Couche géographique NUTS2/3 en fonction de la liste de pays N2
nuts <- rbind(nuts2016_2[nuts2016_2$CNTR_CODE %in% N2, ],
nuts2016_3[!nuts2016_3$CNTR_CODE %in% N2, ])
# Suppression des départements d'Outre-mer français
nuts <- nuts[!nuts$id %in% c("FRY10", "FRY20", "FRY30", "FRY40", "FRY50"), ]
# Suppression du découpage NUTS 2016 pour le Royaume-Uni
nuts <- nuts[nuts$CNTR_CODE != "UK", ]
# Sélection et renommage de colonnes
nuts <- nuts[,c("id","NUTS_NAME","geometry")]
colnames(nuts) <- c("id","name","geometry")
# Récupération du découpage NUTS2 2013
nuts2013 <- get_eurostat_geospatial(
output_class = "sf",
resolution = "20",
nuts_level = "2",
year = "2013")
# Sélection des NUTS2 du Royaume-Uni et renommage de colonnes
uk <- nuts2013[nuts2013$CNTR_CODE == "UK",]
# Sélection et renommage de colonnes
uk <- uk[,c("id","NUTS_NAME","geometry")]
colnames(uk) <- c("id","name","geometry")
# Fusion des NUTS2 2013 du Royaume-Uni avec le fond de carte NUTS2/3 2016
nuts <- rbind(nuts, uk)
par(mar = c(0, 0, 0, 0), mfrow = c(1, 3))
mf_map(nuts, col = "#CCCCCC", border = NA)
mf_map(nuts[substr(nuts$id,1,2) %in%  c("AT", "BE", "CH", "DE", "EL", "NL", "TR", "IE", "IS", "NO"),],
col = "#6eb1db",
border = "white",
lwd = 0.2, add = TRUE)
mf_title("NUTS 2 (version 2016)", bg = "#6eb1db")
mf_map(nuts, col = "#CCCCCC", border = NA)
mf_map(nuts[!substr(nuts$id,1,2) %in%  c("AT", "BE", "CH", "DE", "EL", "NL", "UK", "TR", "IE", "IS", "NO", "UK"),],
col = "#6eb1db",
border = "white",
lwd = 0.2, add = TRUE)
mf_title("NUTS 3 (version 2016)", bg = "#6eb1db")
mf_map(nuts, col = "#CCCCCC", border = NA)
mf_map(nuts[substr(nuts$id,1,2) == "UK",],
col = "#6eb1db",
border = "white",
lwd = 0.2, add = TRUE)
mf_title("NUTS 2 (version 2013)", bg = "#6eb1db")
# Récupération des données (PIB/hab)
var <- "nama_10r_3gdp"
gdpinh <- get_eurostat(var, time_format = "num")
# Sélection de l'unité de mesure et de la date
gdpinh <- gdpinh[gdpinh$unit == "EUR_HAB",]
gdpinh <- gdpinh[gdpinh$time == 2016, c("geo","values")]
colnames(gdpinh) <- c("id","GDPINH_2016")
missing <- read.csv("data/missing.csv")
gdpinh <- rbind(gdpinh, missing)
write.csv(gdpinh, "data/gdpinh.csv")
nuts <- merge(
x = nuts,
y = gdpinh,
by = "id",
all.x = TRUE)
land <- ne_download(
scale = 110,
type = "land",
category = "physical",
returnclass = "sf")
mf_map(land, border = NA, col = "#6eb1db")
ocean <- ne_download(
scale = 110,
type = "ocean",
category = "physical",
returnclass = "sf")
mf_map(ocean, border = NA, col = "#6eb1db")
graticule = st_graticule(
crs = st_crs(4326),
ndiscr = 100,
lon = seq(-180, 180, by = 2),
lat = seq(-90, 90, by = 1),
margin = 0.01)
mf_map(graticule, col = "#6eb1db")
bb <- st_as_sfc(x = st_bbox(c(xmin = -50 , xmax = 70, ymin = 20, ymax = 80),
crs = st_crs(4326)))
sf_use_s2(FALSE)
ocean <- st_intersection(ocean, bb)
ocean <-  st_segmentize(ocean, 100)
land <- st_intersection(land, bb)
land <-  st_segmentize(land, 100)
graticule <- st_intersection(graticule, bb)
sf_use_s2(TRUE)
?proj4string
par(mar = c(0, 0, 0, 0), mfrow = c(2, 2))
mf_map(land, col = "#6eb1db", border = NA)
mf_title("land", bg = "#6eb1db")
mf_map(ocean, col = "#6eb1db", border = NA)
mf_title("ocean", bg = "#6eb1db")
mf_map(graticule, col = "#6eb1db", lwd = 1)
mf_title("graticule", bg = "#6eb1db")
mf_map(nuts,
col = "#6eb1db",
border = "white",
lwd = 0.2)
mf_title("nuts", bg = "#6eb1db")
# dev.off()
# Définition de la projection en format "proj-strings" (PROJ.4)
ortho <- "+proj=ortho +lat_0=-10 +lon_0=15 +x_0=0 +y_0=0
+ellps=WGS84 +units=m +no_defs"
# Reprojection des couches
ocean <- st_transform(ocean, ortho)
land <- st_transform(land, ortho)
graticule <-  st_transform(graticule, ortho)
nuts <- st_transform(nuts, ortho)
par(mar = c(0, 0, 0, 0), mfrow = c(2, 2))
mf_map(land, col = "#6eb1db", border = NA)
mf_title("land", bg = "#6eb1db")
mf_map(ocean, col = "#6eb1db", border = NA)
mf_title("ocean", bg = "#6eb1db")
mf_map(graticule, col = "#6eb1db", lwd = 1)
mf_title("graticule", bg = "#6eb1db")
mf_map(nuts,
col = "#6eb1db",
border = "white",
lwd = 0.2)
mf_title("nuts", bg = "#6eb1db")
# dev.off()
# Union de l'ensemble des entités de la couche géographique nuts
fr <- st_union(nuts[substr(nuts$id, 1, 2) == "FR", ])
par(mar = c(0, 0, 0, 0))
mf_map(fr + c(5000,-5000), col = "#827e6c40", border = NA)
mf_map(fr + c(10000,-10000),
col = "#827e6c40",
border = NA,
add = TRUE)
mf_map(fr + c(5000,-5000), col = "#827e6c40", border = NA)
mf_map(fr + c(10000,-10000),
col = "#827e6c40",
border = NA,
add = TRUE)
mf_map(fr + c(15000,-15000),
col = "#827e6c40",
border = NA,
add = TRUE)
# Paramètrage des marges de la fenêtre graphique à 0
par(mar = c(0, 0, 0, 0))
# Affichage multiple de la couche, en appliquant à chaque fois un léger décalage
mf_map(fr + c(5000,-5000), col = "#827e6c40", border = NA)
mf_map(fr + c(10000,-10000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(fr + c(15000,-15000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(fr + c(20000,-20000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(fr + c(25000,-25000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(fr, col = "#6eb1db", border = "white", lwd = 0.1, add = TRUE)
mf_map(fr + c(5000,-5000), col = "#827e6c40", border = NA)
mf_map(fr + c(10000,-10000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(fr + c(15000,-15000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(fr + c(20000,-20000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(fr + c(25000,-25000), col = "#827e6c60", border = NA, add = TRUE)
mf_map(fr, col = "#6eb1db", border = "white", lwd = 0.1, add = TRUE)
mf_map(fr + c(5000,-5000), col = "#827e6c40", border = NA)
mf_map(fr + c(10000,-10000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(fr + c(15000,-15000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(fr + c(20000,-20000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(fr + c(25000,-25000), col = "#827e6c80", border = NA, add = TRUE)
mf_map(fr, col = "#6eb1db", border = "white", lwd = 0.1, add = TRUE)
mf_map(fr + c(5000,-5000), col = "#827e6c40", border = NA)
mf_map(fr + c(10000,-10000), col = "#827e6c80", border = NA, add = TRUE)
mf_map(fr + c(15000,-15000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(fr + c(20000,-20000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(fr + c(25000,-25000), col = "#827e6c10", border = NA, add = TRUE)
mf_map(fr, col = "#6eb1db", border = "white", lwd = 0.1, add = TRUE)
k <- 100000
extent <- c(-20, 42, 24.5, 63) * k
bb <- st_as_sfc(x= st_bbox(c(xmin = extent[1], xmax = extent[3], ymin = extent[2], ymax = extent[4]),
crs = st_crs(nuts)))
clas(bb)
class(bb)
?text
# Affichage de la couche 'ocean'
mf_map(ocean, col = "#9acbe3", border = "#9acbe3", lwd = 5, add = TRUE)
?dev.off()
# Auto-intersection de la couche NUTS (avec buffer de 5m)
nuts.borders  <- st_intersection(st_buffer(nuts, 5), st_buffer(nuts, 5))
# Auto-intersection de la couche NUTS (avec buffer de 5m)
nuts.borders  <- st_intersection(st_buffer(nuts, 5), st_buffer(nuts, 5))
# Géométrie de sortie en 'MULTILINESTRING'
nuts.borders  <- st_cast(nuts.borders ,"MULTILINESTRING")
View(nuts.borders)
# Récupération des données de PIB par habitant, en supprimant la géométrie associée
vals <- nuts[,c("id","GDPINH_2016")] |> st_set_geometry(NULL)
# Récupération des données de PIB par habitant, en supprimant la géométrie associée
vals <- nuts[,c("id","GDPINH_2016")] |> st_set_geometry(NULL)
# Récupération des données de PIB par habitant, en supprimant la géométrie associée
vals <-
nuts[,c("id","GDPINH_2016")] |> st_set_geometry(NULL)
nuts[,c("id","GDPINH_2016")] |> st_set_geometry(NULL)
# Auto-intersection de la couche NUTS (avec buffer de 5m)
nuts.borders  <- st_intersection(st_buffer(nuts, 5), st_buffer(nuts, 5))
# Géométrie de sortie en 'MULTILINESTRING'
nuts.borders  <- st_cast(nuts.borders ,"MULTILINESTRING")
# Suppression des intersections entre les mêmes polygones
nuts.borders  <- nuts.borders [nuts.borders $id != nuts.borders $id.1, ]
# Construction d'un identifiant unique pour chaque frontière
nuts.borders$id1 <- nuts.borders$id
nuts.borders$id2 <- nuts.borders$id.1
nuts.borders$id <-  paste0(nuts.borders$id1, "_", nuts.borders$id2)
rownames(nuts.borders) <- nuts.borders$id
nuts.borders  <- nuts.borders [,c("id","id1","id2","geometry")]
nuts[,c("id","GDPINH_2016")] |> st_set_geometry(NULL)
?st_cast
sessionInfo()
