nuts.borders  <- st_cast(nuts.borders ,"MULTILINESTRING")
# Suppression des intersections entre les mêmes polygones
nuts.borders  <- nuts.borders [nuts.borders $id != nuts.borders $id.1, ]
# Construction d'un identifiant unique pour chaque frontière
nuts.borders$id1 <- nuts.borders$id
nuts.borders$id2 <- nuts.borders$id.1
nuts.borders$id <-  paste0(nuts.borders$id1, "_", nuts.borders$id2)
rownames(nuts.borders) <- nuts.borders$id
nuts.borders  <- nuts.borders [,c("id","id1","id2","geometry")]
# Récupération des données de PIB par habitant, en supprimant la géométrie associée
vals <- st_set_geometry(x = nuts[, c("id","GDPINH_2016")],
value = NULL)
# Double jointure pour récupérer les valeurs des deux entités limitrophes
nuts.borders <- merge (x = nuts.borders, y = vals, by.x = "id1", by.y = "id", all.x = T)
nuts.borders <- merge (x = nuts.borders, y = vals, by.x = "id2", by.y = "id", all.x = T)
nuts.borders$disc <- nuts.borders$GDPINH_2016.x / nuts.borders$GDPINH_2016.y
threshold <- 0.95
disc <- nuts.borders[nuts.borders$disc >= quantile(nuts.borders$disc,threshold),]
template("figures/fig3.png")
mf_map(x = disc,
col = "#d92e94",
lwd = 3,
add = TRUE)
dev.off()
# On sélectionne une ligne (frontière) au hasard
line <- st_geometry(disc[5, ])
# nombre d'itérations
nb <- 15
# valeur de translation
delta <- 200
# Paramétrage des marges et de la couleur de fond
par(mar = c(0, 0, 0, 0), bg = "#f2efe6")
# Affichage de la frontière
mf_map(line, col = "#66666690", lwd = 0.5)
# 'nb' affichage de la frontière, décalée de 'delta' à chaque fois
for (j in 1:nb) {
line <- line + c(0, delta)
mf_map(line,
col = "#66666690",
lwd = 0.5 ,
add = TRUE)
}
# Affichage de la dernière ligne calculée en rouge, avec une épaisseur de 1.2
mf_map(line,
col = "#cf0e00",
lwd = 1.2,
add = TRUE)
# Transformation du type de géométrie
disc <- st_cast(disc,"LINESTRING")
# Calcul des coordonnées des centroïdes de chaque lignes
c <- as.data.frame(st_coordinates(st_centroid(disc)))
# Récupération de la valeur y de chaque centroïde
disc$Y <- c$Y
# Tri des discontinuités en fonction de la valeur de y
disc <- disc[order(disc$Y, decreasing = TRUE), ]
# Rééchelonnage des valeurs de discontinuité, de 30 à 70
disc$height <- round(rescale(disc$disc, to=c(30,70)),0)
disc$col <-"#cf0e00"
disc$thickness <- 1.2
disc$c1 <- substr(disc$id1,1,2)
disc$c2 <- substr(disc$id2,1,2)
# Boucle qui parcours toutes les lignes
for (i in 1:length(disc$disc)){
# Pays 1 == Pays 2 ?
if (disc$c1[i]== disc$c2[i]) {
disc$height[i] <- 8
disc$col[i] <-"#66666690"
disc$thickness[i] <- 0.5
}
}
# valeur de translation
delta <- 2500
# Création de la fonction extrude()
extrude <- function(id){
line <- st_geometry(disc[id,])
mf_map(line, col= "#66666690",lwd = 0.5 ,add= TRUE)
nb <- as.numeric(disc[id,"height"])[1]
for (j in 1:nb){
line <- st_geometry(line) + c(0,delta)
mf_map(st_geometry(line), col= "#66666690",lwd = 0.5 ,add= TRUE)
}
mf_map(line, col= disc$col[id],lwd = disc$thickness[id] ,add= TRUE)
}
mf_theme(x = "default",
bg = "#f2efe6",
fg = "#f2efe6",
mar = c(0, 0, 0, 0),
tab = TRUE,
pos = "left",
inner = FALSE,
line = 2,
cex = 1.9,
font = 3)
# Affichage de la couche 'ocean'
mf_map(ocean, col = "#9acbe3", border = "#9acbe3", lwd = 5, add = TRUE)
# Création d'un thème
theme <- mf_theme(x = "default",
bg = "#f2efe6",
fg = "#f2efe6",
mar = c(0, 0, 0, 0),
tab = TRUE,
pos = "left",
inner = FALSE,
line = 2,
cex = 1.9,
font = 3)
# Paramétrage de l'export de la carte en format png
mf_export(bb,
export = "png",
width = 2000,
filename = file,
res = 150,
theme = theme,
expandBB = c(-.02, 0, 0.05, 0))
mf_theme(x = "default",
bg = "#f2efe6",
fg = "#f2efe6",
mar = c(0, 0, 0, 0),
tab = TRUE,
pos = "left",
inner = FALSE,
line = 2,
cex = 1.9,
font = 3)
mf_map(ocean, col = "#9acbe3", border = "#9acbe3", lwd = 5)
dev.off()
dev.off()
function (which = dev.cur())
dev.off()
# Affichage de la couche 'graticule'
mf_map(graticule, col = "#FFFFFF80", lwd = 1.5, lty = 3, add = TRUE)
mf_map(ocean, col = "#9acbe3", border = "#9acbe3", lwd = 5)
# Affichage de la couche 'graticule'
mf_map(graticule, col = "#FFFFFF80", lwd = 1.5, lty = 3, add = TRUE)
# Affichage d'un effet d'ombrage pour la couche 'nuts'
ue <- st_union(nuts)
mf_map(ue + c(5000,-5000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(ue + c(10000,-10000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(ue + c(15000,-15000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(ue + c(20000,-20000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(ue + c(25000,-25000), col = "#827e6c40", border = NA, add = TRUE)
# Affichage de la couche 'nuts'
mf_map(nuts, col = "#dbccb6", border = "white", lwd = 0.3, add = TRUE)
# Affichage d'un bandeau bleu transparent sous le titre
rect(-22 * k,
41.3 * k,
28 * k,
41.3 * k + 250000,
border = NA, col = "#2369bd80")
# Affichage du titre
text(x = -21.5 * k,
y = 42.4 * k,
labels = "30 YEARS LATER, THE IRON CURTAIN IS STILL VISIBLE",
cex = 2.14,
pos = 4,
font = 2,
col = "#FFFFFF80")
# Affichage des sources
text(x = -21.75 * k,
y = 44.25 * k,
labels = "Map 100% designed in the R language by Nicolas Lambert, 2019.
Code source available here: https://github.com/neocarto/ironcurtain). Data sources: Eurostat & Natural Earth, 2019",
cex = 0.5,
pos = 4,
font = 1,
col = "#3f4654")
# Affichage d'une échelle
mf_scale(size = 700,
lwd = 0.6,
cex = 0.5,
col = "#3f4654",
pos = c(19 * k, y = 44 * k))
# Affichage de la couche 'ocean'
mf_map(ocean, col = "#9acbe3", border = "#9acbe3", lwd = 5)
# Affichage de la couche 'ocean'
mf_map(ocean, col = "#9acbe3", border = "#9acbe3", lwd = 5)
for (i in 1:length(disc$height))
{
extrude(i)
}
apply(X =disc, MARGIN = 1, FUN =  extrude())
sapply(disc, FUN = extrude())
sapply(disc, FUN = extrude(disc$height))
sapply(disc$height, FUN = extrude())
apply(disc$height, 2, FUN = extrude())
apply(disc$height, c(1, 2), FUN = extrude())
df <- data.frame(x = 1:4, y = 5:8, z = 10:13)
df
apply(df, c(1, 2), FUN = extrude())
apply(df, c(1, 2), FUN = sum)
apply(df, 1, FUN = sum)
apply(df, c(1, 2), FUN = extrude)
apply(df$x, c(1, 2), FUN = extrude)
df$x
apply(df$x, 1, FUN = extrude)
apply(df$x, 2, FUN = extrude)
apply(df, 1, FUN = sum)
df
ff <- fonction(x){x+2}
ff <- fonction(x){x+2}
ff <- fonction(x){
x+2
}
ff <- fonction(x){
x+2
}
}
}
}
}
}
}
}
}
}
}
}
}
{
{
{
{
}
}
}
}
}
}
}
ff <- fonction(x){
x+2
}
ff <- function(x){
x+2
}
apply(df, 1, FUN = ff)
df
apply(disc$height, 1, FUN = extrude)
disc$height
apply(disc[, c(8,9)], 1, FUN = extrude)
disc[, c(8,9)]
# Habillage
d = 0.75 * k
text(14.4*k - d, y = 57.4*k, "Discontinuities", cex = 0.6,
pos = 4, font = 2, col="#404040")
text(15.5*k - d, y = 56.6*k, "Between two regions of the same country",
cex = 0.4, pos = 4, font = 1, col="#404040")
text(15.5*k - d, y = 55.7*k, "Between two regions of two different countries",
cex = 0.4, pos = 4, font = 1, col="#404040")
text(15.5*k - d, y = 55.3*k,
"(The height is proportional to the value of the dicontinuity)",
cex = 0.4, pos = 4, font = 1, col="#404040")
text(10.7*k, y = 54.4*k,
"NB: only the 10% highest discontinuities are represented on the map.",
cex = 0.4, pos = 4, font = 3, col="#404040")
# Symboles pour la légende
myline <- disc[disc$id == "TR21_BG341",]
st_geometry(myline) <- st_geometry(myline) + c(4.2*k, 5*k)
myline2 <- myline
st_geometry(myline2) <- st_geometry(myline2) + c(0, 1.5*k)
plot(myline, col= "#66666690",lwd = 0.5 ,add= T)
for (i in 1:40){
myline <- st_geometry(myline) + c(0,delta)
plot(st_geometry(myline), col= "#66666690",lwd = 0.5 ,add= T)
}
plot(myline, col= "#cf0e00",lwd = 1.2 ,add= T)
plot(myline2, col= "#66666690",lwd = 0.5 ,add= T)
for (i in 1:8){
myline2 <- st_geometry(myline2) + c(0,delta)
plot(st_geometry(myline2), col= "#66666690",lwd = 0.5 ,add= T)
}
plot(myline2, col= "#66666690",lwd = 0.5 ,add= T)
# Affichage de la couche 'ocean'
mf_map(ocean, col = "#9acbe3", border = "#9acbe3", lwd = 5)
# Affichage de la couche 'graticule'
mf_map(graticule, col = "#FFFFFF80", lwd = 1.5, lty = 3, add = TRUE)
# Affichage d'un effet d'ombrage pour la couche 'nuts'
ue <- st_union(nuts)
mf_map(ue + c(5000,-5000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(ue + c(10000,-10000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(ue + c(15000,-15000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(ue + c(20000,-20000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(ue + c(25000,-25000), col = "#827e6c40", border = NA, add = TRUE)
# Affichage de la couche 'nuts'
mf_map(nuts, col = "#dbccb6", border = "white", lwd = 0.3, add = TRUE)
# Affichage d'un bandeau bleu transparent sous le titre
rect(-22 * k,
41.3 * k,
28 * k,
41.3 * k + 250000,
border = NA, col = "#2369bd80")
# Affichage du titre
text(x = -21.5 * k,
y = 42.4 * k,
labels = "30 YEARS LATER, THE IRON CURTAIN IS STILL VISIBLE",
cex = 2.14,
pos = 4,
font = 2,
col = "#FFFFFF80")
# Affichage des sources
text(x = -21.75 * k,
y = 44.25 * k,
labels = "Map 100% designed in the R language by Nicolas Lambert, 2019.
Code source available here: https://github.com/neocarto/ironcurtain). Data sources: Eurostat & Natural Earth, 2019",
cex = 0.5,
pos = 4,
font = 1,
col = "#3f4654")
# Affichage d'une échelle
mf_scale(size = 700,
lwd = 0.6,
cex = 0.5,
col = "#3f4654",
pos = c(19 * k, y = 44 * k))
# Affichage de la couche 'ocean'
mf_map(ocean, col = "#9acbe3", border = "#9acbe3", lwd = 5)
# Affichage de la couche 'graticule'
mf_map(graticule, col = "#FFFFFF80", lwd = 1.5, lty = 3, add = TRUE)
# Affichage d'un effet d'ombrage pour la couche 'nuts'
ue <- st_union(nuts)
mf_map(ue + c(5000,-5000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(ue + c(10000,-10000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(ue + c(15000,-15000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(ue + c(20000,-20000), col = "#827e6c40", border = NA, add = TRUE)
mf_map(ue + c(25000,-25000), col = "#827e6c40", border = NA, add = TRUE)
# Affichage de la couche 'nuts'
mf_map(nuts, col = "#dbccb6", border = "white", lwd = 0.3, add = TRUE)
# Affichage d'un bandeau bleu transparent sous le titre
rect(-22 * k,
41.3 * k,
28 * k,
41.3 * k + 250000,
border = NA, col = "#2369bd80")
# Affichage du titre
text(x = -21.5 * k,
y = 42.4 * k,
labels = "30 YEARS LATER, THE IRON CURTAIN IS STILL VISIBLE",
cex = 2.14,
pos = 4,
font = 2,
col = "#FFFFFF80")
# Affichage des sources
text(x = -21.75 * k,
y = 44.25 * k,
labels = "Map 100% designed in the R language by Nicolas Lambert, 2019.
Code source available here: https://github.com/neocarto/ironcurtain). Data sources: Eurostat & Natural Earth, 2019",
cex = 0.5,
pos = 4,
font = 1,
col = "#3f4654")
# Affichage d'une échelle
mf_scale(size = 700,
lwd = 0.6,
cex = 0.5,
col = "#3f4654",
pos = c(19 * k, y = 44 * k))
# Boucle for pour appliquer la fonction extrude() à toutes les lignes
for (i in 1:length(disc$height))
{
extrude(i)
}
# Ajout d'une légende pour les discontinuités
# Utilisation du facteur k pour un placement précis des éléments
d = 0.75 * k
# Titre légende
text(14.4*k - d, y = 57.4*k, "Discontinuities",
cex = 0.6, pos = 4, font = 2, col="#404040")
# classe légende
text(15.5*k - d, y = 56.6*k, "Between two regions of the same country",
cex = 0.4, pos = 4, font = 1, col="#404040")
# classe légende
text(15.5*k - d, y = 55.7*k, "Between two regions of two different countries",
cex = 0.4, pos = 4, font = 1, col="#404040")
# Description légende
text(15.5*k - d, y = 55.3*k,
"(The height is proportional to the value of the dicontinuity)",
cex = 0.4, pos = 4, font = 1, col="#404040")
# NB légende
text(10.7*k, y = 54.4*k,
"NB: only the 10% highest discontinuities are represented on the map.",
cex = 0.4, pos = 4, font = 3, col="#404040")
# Symboles pour la légende
myline <- disc[disc$id == "TR21_BG341",]
st_geometry(myline) <- st_geometry(myline) + c(4.2*k, 5*k)
myline2 <- myline
st_geometry(myline2) <- st_geometry(myline2) + c(0, 1.5*k)
# discontinuités entre deux régions de deux pays différentes
plot(myline, col= "#66666690",lwd = 0.5 ,add= T)
for (i in 1:40){
myline <- st_geometry(myline) + c(0,delta)
plot(st_geometry(myline), col= "#66666690",lwd = 0.5 ,add= T)
}
plot(myline, col= "#cf0e00",lwd = 1.2 ,add= T)
# discontinuités entre deux régions d'un même pays
plot(myline2, col= "#66666690",lwd = 0.5 ,add= T)
for (i in 1:8){
myline2 <- st_geometry(myline2) + c(0,delta)
plot(st_geometry(myline2), col= "#66666690",lwd = 0.5 ,add= T)
}
plot(myline2, col= "#66666690",lwd = 0.5 ,add= T)
# Construction de symboles pour la légende
myline <- disc[disc$id == "TR21_BG341",]
st_geometry(myline)
template("figures/fig4.png")
# BOUCLE for pour appliquer la fonction extrude() à toutes les lignes
for (i in 1:length(disc$height))
{
extrude(i)
}
# TEXTE de la légende pour les discontinuités
# Utilisation du facteur k pour un placement précis des éléments
d = 0.75 * k
# Titre légende
text(14.4*k - d, y = 57.4*k, "Discontinuities",
cex = 0.6, pos = 4, font = 2, col="#404040")
# Intitulé classe 1
text(15.5*k - d, y = 56.6*k, "Between two regions of the same country",
cex = 0.4, pos = 4, font = 1, col="#404040")
# Intitulé classe 2
text(15.5*k - d, y = 55.7*k, "Between two regions of two different countries",
cex = 0.4, pos = 4, font = 1, col="#404040")
# Description
text(15.5*k - d, y = 55.3*k,
"(The height is proportional to the value of the dicontinuity)",
cex = 0.4, pos = 4, font = 1, col="#404040")
# NB
text(10.7*k, y = 54.4*k,
"NB: only the 10% highest discontinuities are represented on the map.",
cex = 0.4, pos = 4, font = 3, col="#404040")
# SYMBOLE pour la légende
# Récupération d'un ligne infra-nationale presque horizontale
myline <- disc[disc$id == "TR21_BG341",]
# On duplique a ligne
myline2 <- myline
# Translation de la ligne pour la positionner dans la légende (Classe 1)
st_geometry(myline) <- st_geometry(myline) + c(4.2*k, 5*k)
# Translation de la ligne pour la positionner dans la légende (Classe 2)
myline2 <- myline
st_geometry(myline2) <- st_geometry(myline2) + c(0, 1.5*k)
# Construction du symbole pour les discontinuités entre deux pays
plot(myline, col= "#66666690",lwd = 0.5 ,add= T)
# 40 itération de la ligne
for (i in 1:40){
myline <- st_geometry(myline) + c(0,delta)
plot(st_geometry(myline), col= "#66666690",lwd = 0.5 ,add= T)
}
# Dernière ligne en rouge
plot(myline, col= "#cf0e00",lwd = 1.2 ,add= T)
# Construction du symbole pour les discontinuités infra-nationale
plot(myline2, col= "#66666690",lwd = 0.5 ,add= T)
# 8 itération de la ligne
for (i in 1:8){
myline2 <- st_geometry(myline2) + c(0,delta)
plot(st_geometry(myline2), col= "#66666690",lwd = 0.5 ,add= T)
}
# Ne pas oublier :
dev.off()
template("figures/fig4.png")
# BOUCLE for pour appliquer la fonction extrude() à toutes les lignes
for (i in 1:length(disc$height))
{
extrude(i)
}
# TEXTE de la légende pour les discontinuités
# Utilisation du facteur k pour un placement précis des éléments
d = 0.75 * k
# Titre légende
text(14.4*k - d, y = 57.4*k, "Discontinuities",
cex = 0.6, pos = 4, font = 2, col="#404040")
# Intitulé classe 1
text(15.5*k - d, y = 56.6*k, "Between two regions of the same country",
cex = 0.4, pos = 4, font = 1, col="#404040")
# Intitulé classe 2
text(15.5*k - d, y = 55.7*k, "Between two regions of two different countries",
cex = 0.4, pos = 4, font = 1, col="#404040")
# Description
text(15.5*k - d, y = 55.3*k,
"(The height is proportional to the value of the dicontinuity)",
cex = 0.4, pos = 4, font = 1, col="#404040")
# NB
text(10.7*k, y = 54.4*k,
"NB: only the 10% highest discontinuities are represented on the map.",
cex = 0.4, pos = 4, font = 3, col="#404040")
# SYMBOLE pour la légende
# Récupération d'un ligne infra-nationale presque horizontale
myline <- disc[disc$id == "TR21_BG341",]
# On duplique a ligne
myline2 <- myline
# Translation de la ligne pour la positionner dans la légende (Classe 1)
st_geometry(myline) <- st_geometry(myline) + c(4.2*k, 5*k)
# Translation de la ligne pour la positionner dans la légende (Classe 2)
myline2 <- myline
st_geometry(myline2) <- st_geometry(myline2) + c(0, 1.5*k)
# Construction du symbole pour les discontinuités entre deux pays
plot(myline, col= "#66666690",lwd = 0.5 ,add= T)
# 40 itération de la ligne
for (i in 1:40){
myline <- st_geometry(myline) + c(0,delta)
plot(st_geometry(myline), col= "#66666690",lwd = 0.5 ,add= T)
}
# Dernière ligne en rouge
plot(myline, col= "#cf0e00",lwd = 1.2 ,add= T)
# Construction du symbole pour les discontinuités infra-nationale
plot(myline2, col= "#66666690",lwd = 0.5 ,add= T)
# 8 itération de la ligne
for (i in 1:8){
myline2 <- st_geometry(myline2) + c(0,delta)
plot(st_geometry(myline2), col= "#66666690",lwd = 0.5 ,add= T)
}
plot(myline2, col= "#66666690",lwd = 0.5 ,add= T)
# Ne pas oublier
dev.off()
